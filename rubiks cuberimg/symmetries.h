#pragma once
#include <array>

#include "cubie.h"

//All the below definitions for each of the symmetries are taken directly 
//from Kociemba's python solution

//There are 48 in total but they can all be generated by multiplying
//these 4 together in various ways.

void gen_symmetries() {
	// 120° clockwise rotation around the long diagonal URF - DBL
	cubie sym_URF3;
	sym_URF3.corn_perm = { URF, DFR, DLF, UFL, UBR, DRB, DBL, ULB };
	sym_URF3.corn_ori = { 1, 2, 1, 2, 2, 1, 2, 1 };
	sym_URF3.edge_perm = { UF, FR, DF, FL, UB, BR, DB, BL, UR, DR, DL, UL };
	sym_URF3.edge_ori = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1 };

	// 180° rotation around the axis through the f and b centers
	cubie sym_F2;
	sym_F2.corn_perm = { DLF, DFR, DRB, DBL, UFL, URF, UBR, ULB };
	sym_F2.corn_ori = { 0, 0, 0, 0, 0, 0, 0, 0 };
	sym_F2.edge_perm = { DL, DF, DR, DB, UL, UF, UR, UB, FL, FR, BR, BL };
	sym_F2.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	// 90° clockwise rotation around the axis through the u and d centers
	cubie sym_U4;
	sym_U4.corn_perm = { UBR, URF, UFL, ULB, DRB, DFR, DLF, DBL };
	sym_U4.corn_ori = { 0, 0, 0, 0, 0, 0, 0, 0 };
	sym_U4.edge_perm = { UB, UR, UF, UL, DB, DR, DF, DL, BR, FR, FL, BL };
	sym_U4.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 };

	// reflection at the plane through the u, d, f, b centers
	cubie sym_LR2;
	sym_LR2.corn_perm = { UFL, URF, UBR, ULB, DLF, DFR, DRB, DBL };
	sym_LR2.corn_ori = { 3, 3, 3, 3, 3, 3, 3, 3 };
	sym_LR2.edge_perm = { UL, UF, UR, UB, DL, DF, DR, DB, FL, FR, BR, BL };
	sym_LR2.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	std::array <cubie, 48> symmetries;


	short i = 0;
	cubie c;


	//The below produces each of the 48 symmetries

	for (short urf3 = 0; urf3 != 3; urf3++) {
		for (short fb2 = 0; fb2 != 2; fb2++) {
			for (short ud4 = 0; ud4 != 4; ud4++) {
				for (short lr2 = 0; lr2 != 2; lr2++) {
					symmetries[i] = c;
					i++;
					c.multiply(sym_LR2);
				}
				c.multiply(sym_U4);
			}
			c.multiply(sym_F2);
		}
		c.corner_multiply(sym_URF3);
	}
}





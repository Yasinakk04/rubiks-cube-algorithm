#pragma once

#include <fstream>
#include <array>
#include <stdlib.h>
#include <vector>

#include "moves.h"
#include "cubie.h"


//All the below definitions for each of the symmetries are taken directly
//from Kociemba's python solution

//There are 48 in total but they can all be generated by multiplying
//these 4 together in various ways.

std::array <cubie, 48> gen_symmetries() {
	// 120° clockwise rotation around the long diagonal URF - DBL
	cubie sym_URF3;
	sym_URF3.corn_perm = { URF, DFR, DLF, UFL, UBR, DRB, DBL, ULB };
	sym_URF3.corn_ori = { 1, 2, 1, 2, 2, 1, 2, 1 };
	sym_URF3.edge_perm = { UF, FR, DF, FL, UB, BR, DB, BL, UR, DR, DL, UL };
	sym_URF3.edge_ori = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1 };

	// 180° rotation around the axis through the f and b centers
	cubie sym_F2;
	sym_F2.corn_perm = { DLF, DFR, DRB, DBL, UFL, URF, UBR, ULB };
	sym_F2.corn_ori = { 0, 0, 0, 0, 0, 0, 0, 0 };
	sym_F2.edge_perm = { DL, DF, DR, DB, UL, UF, UR, UB, FL, FR, BR, BL };
	sym_F2.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	// 90° clockwise rotation around the axis through the u and d centers
	cubie sym_U4;
	sym_U4.corn_perm = { UBR, URF, UFL, ULB, DRB, DFR, DLF, DBL };
	sym_U4.corn_ori = { 0, 0, 0, 0, 0, 0, 0, 0 };
	sym_U4.edge_perm = { UB, UR, UF, UL, DB, DR, DF, DL, BR, FR, FL, BL };
	sym_U4.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 };

	// reflection at the plane through the u, d, f, b centers
	cubie sym_LR2;
	sym_LR2.corn_perm = { UFL, URF, UBR, ULB, DLF, DFR, DRB, DBL };
	sym_LR2.corn_ori = { 3, 3, 3, 3, 3, 3, 3, 3 };
	sym_LR2.edge_perm = { UL, UF, UR, UB, DL, DF, DR, DB, FL, FR, BR, BL };
	sym_LR2.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	std::array <cubie, 48> symmetries{};
	short i = 0;
	cubie c;

	//The below produces each of the 48 symmetries

	for (short urf3 = 0; urf3 != 3; urf3++) {
		for (short fb2 = 0; fb2 != 2; fb2++) {
			for (short ud4 = 0; ud4 != 4; ud4++) {
				for (short lr2 = 0; lr2 != 2; lr2++) {
					symmetries[i] = c;
					i++;
					c.multiply(sym_LR2);
				}
				c.multiply(sym_U4);
			}
			c.multiply(sym_F2);
		}
		c.multiply(sym_URF3);
	}

	return symmetries;

}

std::array <cubie, 48> gen_inv_symmetries(std::array <cubie, 48> symmetries) {
	//Now the below is used to get the inverse
	//symmetries.
	//Any symmetry times by a permutation, times by the inverse
	//gives an equivalent cube


	cubie c;
	cubie x;

	c.reset();

	//multiplying a cube by its inverse gives the I
	//cube
	//c has been reset so it is the I cube

	std::array <cubie, 48> inv_symmetries{};
	for (short i = 0; i != 48; i++) {
		for (short j = 0; j != 48; j++) {
			x = symmetries[i];
			x.multiply(symmetries[j]);

			if (x.corn_ori == c.corn_ori &&
				x.corn_perm == c.corn_perm &&
				x.edge_ori == c.edge_ori &&
				x.edge_perm == c.edge_perm) { inv_symmetries[i] = symmetries[j]; break;	}
		}
	}

	return inv_symmetries;
}

std::array <std::array <short, 48>, 18> generate_symmetry_move(std::array <cubie, 48> symmetries,
	std::array <cubie, 48> inv_symmetries) {

	//if you apply a cube to a symmetry cube, you need
	//to be able to work out what that move would mean
	//on a normal cube
	//to do that this 2d array is used

	//this again is also based off of Kociemba's algorithm

	std::array <std::array <short, 48>, 18> symmetry_move_to_move{};

	std::array <cubie, 18> moves = make_moves();

	cubie c;

	for (short s = 0; s != 48; s++) {
		for (short m = 0; m != 18; m++) {
			c = symmetries[s];
			c.multiply(moves[m]);
			c.multiply(inv_symmetries[s]);

			for (short M = 0; M != 18; M++) {
				if (moves[M].corn_ori == c.corn_ori &&
					moves[M].corn_perm == c.corn_perm &&
					moves[M].edge_ori == c.edge_ori &&
					moves[M].edge_perm == c.edge_perm) {
					symmetry_move_to_move[m][s] = M;
				}
			}
		}
	}

	return symmetry_move_to_move;
}
//Similar to how we need to convert the moves
//we also need to be able to convert the twist
//when using a symmetry cube

//2187 is the number of possible twists
//16 is the number of symmetries actually used, as
//the other 32 don't preserve the UD axis, explained
//by Kociemba on his website:
//http://www.kociemba.org/cube.htm


void generate_twist_symmetry(std::array <cubie, 48> symmetries,
	std::array <cubie, 48> inv_symmetries) {
	std::array <unsigned short, 16 * 2187> sym_twist_conversion{};
	cubie x;
	cubie c;

	for (short t = 0; t != 2187; t++) {
		x.set_twist(t);
		
		for (short s = 0; s != 16; s++) {
			c = symmetries[s];
			c.corner_multiply(x);
			c.corner_multiply(inv_symmetries[s]);
			
			sym_twist_conversion[16 * t + s] = c.get_twist();
		}
	}

	std::ofstream something("twist sym table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 16 * 2187; i++) {
		something.write((char*)&(sym_twist_conversion[i]), sizeof(unsigned short));
	}
	something.close();
}

void generate_ud_edges_symmetry(std::array <cubie, 48> symmetries,
	std::array <cubie, 48> inv_symmetries) {

	//Another table is necessary for the u and d edges

	std::array <unsigned short, 40320 * 16> ud_edge_sym_conversion{};

	cubie x;
	cubie c;

	for (unsigned short ud = 0; ud != 40320; ud++) {
		x.set_ud_edges(ud);

		for (short s = 0; s != 16; s++) {
			c = symmetries[s];
			c.edge_multiply(x);
			c.edge_multiply(inv_symmetries[s]);

			ud_edge_sym_conversion[16 * ud + s] = c.get_ud_edges();
		}
	}


	std::ofstream something("ud edges sym table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 16 * 40320; i++) {
		something.write((char*)&(ud_edge_sym_conversion[i]), 2);
	}
	something.close();

	std::cout << "ud edge symmetry table generated";
}




 //In order to use symmetries, you need to be
 //able to figure out which symmetry corresponds to which permutation
 //this is done using the values for the flip and permutation
 //of the ud slice edges
 

void generate_flipslices_symmetry_and_classes(std::array <cubie, 48> symmetries,
	std::array <cubie, 48> inv_symmetries) {

	cubie c;
	cubie x;

	std::vector <unsigned int> flipslice_sym_classes{}; //This groups a number of ud slices that are
															//considered equivalent by symmetries
																//2048 * 495

	std::vector <unsigned int> flipslice_symmetry{}; //This tells you what symmetry is applied to
													//a specific ud slice permutation

	std::vector <unsigned short> flipslice_sym_rep{}; //This tells you the ud slice used to represent
														//a specific ud slice permutation and the flip of all edges



	for (unsigned int i = 0; i != 1013760; i++) {
		flipslice_sym_classes.push_back(2000000);
		flipslice_symmetry.push_back(0);
	}

	for (unsigned int i = 0; i != 64430; i++) {
		flipslice_sym_rep.push_back(0);
	}

														//The algorithm fills in all the permutations for one class before moving to the next
														//because it is going up from 0, the representent for a permutation
														//in a class is the one with the smallest value

															//the number of classes being 64430 was calculated by Kociemba
															//dividing 2048 * 495 by 16 gives 63360, which is close to the real value


	unsigned short flipslice_value;						//This value is used to define the permutation by its flip
														//and ud slice edge arrangement
	unsigned short flipslice_class = 0;


	for (short ud_slice = 0; ud_slice != 495; ud_slice++) {
		x.set_ud_slice_phase_1(ud_slice);
		for (short f = 0; f != 2048; f++) {
			c.set_flip(f);
			flipslice_value = 2048 * ud_slice + f;

			if (flipslice_sym_classes[flipslice_value] == 2000000) {
				flipslice_sym_classes[flipslice_value] = flipslice_class;
				flipslice_symmetry[flipslice_value] = 0; //Its set to 0 because it is the base represent of the class
				flipslice_sym_rep[flipslice_class] = flipslice_value;
			}
			else { continue; }

			for (short s = 0; s != 16; s++) {
				cubie sym = symmetries[s];
				sym.edge_multiply(c);
				sym.edge_multiply(inv_symmetries[s]);

				flipslice_value = 2048 * sym.get_ud_slice_phase_1() + sym.get_flip();

				if (flipslice_sym_classes[flipslice_value] == 2000000) {
					flipslice_sym_classes[flipslice_value] = flipslice_class;
					flipslice_symmetry[flipslice_value] = s;
				}
			}
			flipslice_class++;
		}
	}

	std::ofstream flipslice_sym_class_table("flipslice sym class table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 101376; i++) {
		flipslice_sym_class_table.write((char*)&(flipslice_sym_classes[i]), sizeof(unsigned int));
	}
	flipslice_sym_class_table.close();

	std::ofstream flipslice_symmetry_table("flipslice symmetry table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 1013760; i++) {
		flipslice_symmetry_table.write((char*)&(flipslice_symmetry[i]), sizeof(unsigned int));
	}
	flipslice_symmetry_table.close();

	std::ofstream flipslice_sym_rep_table("flipslice sym rep table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 64430; i++) {
		flipslice_sym_rep_table.write((char*)&(flipslice_sym_rep[i]), sizeof(unsigned short));
	}
	flipslice_sym_rep_table.close();
}




 //now we need to do something similar but with the corners

void generate_corner_symmetry_and_classes(std::array <cubie, 48> symmetries,
	std::array <cubie, 48> inv_symmetries) {
	cubie c;
	cubie x;
	cubie sym;

	std::vector <unsigned short> corner_sym_classes{};

	std::vector <unsigned short> corner_symmetry{};

	std::vector <unsigned short> corner_sym_rep{};

	for (unsigned int i = 0; i != 40320; i++) {
		corner_sym_classes.push_back(60000);
		corner_symmetry.push_back(0);
	}

	for (unsigned int i = 0; i != 2769; i++) {
		corner_sym_rep.push_back(0);
	}

	//The algorithm fills in all the permutations for one class before moving to the next
	//because it is going up from 0, the representent for a permutation
	//in a class is the one with the smallest value

		//the number of classes being 64430 was calculated by Kociemba
		//dividing 2048 * 495 by 16 gives 63360, which is close to the real value


	unsigned short corner_value;						//This value is used to define the permutation by its flip
														//and ud slice edge arrangement
	unsigned short corner_class = 0;

	bool increment = false;

	for (int corner = 0; corner < 40320; corner++) {
		x.set_corners(corner);
		if (corner_sym_classes[corner] == 60000) {
			corner_sym_classes[corner] = corner_class;
			corner_symmetry[corner] = 0; //Its set to 0 because it is the base representent of the class
			corner_sym_rep[corner_class] = corner;

			for (short s = 0; s < 16; s++) {
				

				sym = symmetries[s];
				sym.corner_multiply(x);
				sym.corner_multiply(inv_symmetries[s]);

				corner_value = sym.get_corners();

				if (corner_sym_classes[corner_value] == 60000) {
					corner_sym_classes[corner_value] = corner_class;
					corner_symmetry[corner_value] = s;
				}
			}
		}

		else { continue; }

		corner_class++;
	}

	std::ofstream corner_sym_class_table("corner sym class table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 40320; i++) {
		corner_sym_class_table.write((char*)&(corner_sym_classes[i]), sizeof(unsigned short));
	}
	corner_sym_class_table.close();

	std::ofstream corner_symmetry_table("corner symmetry table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 40320; i++) {
		corner_symmetry_table.write((char*)&(corner_symmetry[i]), sizeof(unsigned short));
	}
	corner_symmetry_table.close();

	std::ofstream corner_sym_rep_table("corner sym rep table.bin", std::ios::out | std::ios::binary);

	for (int i = 0; i != 2769; i++) {
		corner_sym_rep_table.write((char*)&(corner_sym_rep[i]), sizeof(unsigned short));
	}
	corner_sym_rep_table.close();
}
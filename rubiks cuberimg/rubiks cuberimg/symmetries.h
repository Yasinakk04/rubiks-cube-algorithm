#pragma once
#include <array>
#include "moves.h"
#include "cubie.h"

//All the below definitions for each of the symmetries are taken directly 
//from Kociemba's python solution

//There are 48 in total but they can all be generated by multiplying
//these 4 together in various ways.

void gen_symmetries() {
	// 120° clockwise rotation around the long diagonal URF - DBL
	cubie sym_URF3;
	sym_URF3.corn_perm = { URF, DFR, DLF, UFL, UBR, DRB, DBL, ULB };
	sym_URF3.corn_ori = { 1, 2, 1, 2, 2, 1, 2, 1 };
	sym_URF3.edge_perm = { UF, FR, DF, FL, UB, BR, DB, BL, UR, DR, DL, UL };
	sym_URF3.edge_ori = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1 };

	// 180° rotation around the axis through the f and b centers
	cubie sym_F2;
	sym_F2.corn_perm = { DLF, DFR, DRB, DBL, UFL, URF, UBR, ULB };
	sym_F2.corn_ori = { 0, 0, 0, 0, 0, 0, 0, 0 };
	sym_F2.edge_perm = { DL, DF, DR, DB, UL, UF, UR, UB, FL, FR, BR, BL };
	sym_F2.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	// 90° clockwise rotation around the axis through the u and d centers
	cubie sym_U4;
	sym_U4.corn_perm = { UBR, URF, UFL, ULB, DRB, DFR, DLF, DBL };
	sym_U4.corn_ori = { 0, 0, 0, 0, 0, 0, 0, 0 };
	sym_U4.edge_perm = { UB, UR, UF, UL, DB, DR, DF, DL, BR, FR, FL, BL };
	sym_U4.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 };

	// reflection at the plane through the u, d, f, b centers
	cubie sym_LR2;
	sym_LR2.corn_perm = { UFL, URF, UBR, ULB, DLF, DFR, DRB, DBL };
	sym_LR2.corn_ori = { 3, 3, 3, 3, 3, 3, 3, 3 };
	sym_LR2.edge_perm = { UL, UF, UR, UB, DL, DF, DR, DB, FL, FR, BR, BL };
	sym_LR2.edge_ori = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	std::array <cubie, 48> symmetries;


	short i = 0;
	cubie c;


	//The below produces each of the 48 symmetries

	for (short urf3 = 0; urf3 != 3; urf3++) {
		for (short fb2 = 0; fb2 != 2; fb2++) {
			for (short ud4 = 0; ud4 != 4; ud4++) {
				for (short lr2 = 0; lr2 != 2; lr2++) {
					symmetries[i] = c;
					i++;
					c.multiply(sym_LR2);
				}
				c.multiply(sym_U4);
			}
			c.multiply(sym_F2);
		}
		c.corner_multiply(sym_URF3);
	}

	c.reset();

	//Now the below is used to get the inverse
	//symmetries. 
	//Any symmetry times by a permutation, times by the inverse
	//gives an equivalent cube

	//multiplying a cube by its inverse gives the I
	//cube
	//c has been reset so it is the I cube

	std::array <cubie, 48> inv_symmetries;
	cubie x;
	for (short i = 0; i != 48; i++) {
		for (short j = 0; j != 48; j++) {
			x = symmetries[i];
			x.multiply(symmetries[j]);

			if (x.corn_ori == c.corn_ori &&
				x.corn_perm == c.corn_perm &&
				x.edge_ori == c.edge_ori &&
				x.edge_perm == c.edge_perm) {
					inv_symmetries[j] = symmetries[i];
					break;
			}
		}
	}

	//if you apply a cube to a symmetry cube, you need
	//to be able to work out what that move would mean
	//on a normal cube
	//to do that this 2d array is used

	//this again is also based off of Kociemba's algorithm

	std::array <std::array <short, 48>, 18> symmetry_move_to_move;

	std::array <cubie, 18> moves = make_moves();

	for (short s = 0; s != 48; s++) {
		for (short m = 0; m != 18; m++) {
			c = symmetries[s];
			c.multiply(moves[m]);
			c.multiply(inv_symmetries[s]);
			
			for (short M = 0; m != 18; M++) {
				if (moves[M].corn_ori == c.corn_ori &&
					moves[M].corn_perm == c.corn_perm &&
					moves[M].edge_ori == c.edge_ori &&
					moves[M].edge_perm == c.edge_perm) {
						symmetry_move_to_move[m][s] = M;
				}
			}
		}
	}

	//Similar to how we need to convert the moves
	//we also need to be able to convert the twist
	//when using a symmetry cube

	//2187 is the number of possible twists
	//16 is the number of symmetries actually used, as
	//the other 32 don't preserve the UD axis, explained
	//by Kociemba on his website:
	//http://www.kociemba.org/cube.htm

	std::array <short, 16 * 2187> sym_twist_conversion;

	x.reset();

	for (short t = 0; t != 2187; t++) {
		x.set_twist(t);
		
		for (short s = 0; s != 16; s++) {
			c = symmetries[s];
			c.multiply(x);
			c.multiply(inv_symmetries[s]);

			sym_twist_conversion[16 * t + s] = c.get_twist();
		}
	}

	//Another table is necessary for the u and d edges

	std::array <short, 16 * 40320> ud_edge_sym_conversion;

	for (unsigned short ud = 0; ud != 40320; ud++) {
		x.set_ud_edges(ud);

		for (short s = 0; s != 16; s++) {
			c = symmetries[s];
			c.multiply(x);
			c.multiply(inv_symmetries[s]);

			ud_edge_sym_conversion[16 * ud + s] = c.get_ud_edges();
		}
	}

	//In order to use symmetries, you need to be
	//able to figure out which symmetry corresponds to which permutation
	//this is done using the values for the flip and permutation
	//of the ud slice edges

	c.reset();
	x.reset();

	std::array <short, 2048 * 495> ud_slice_sym_classes;	//This groups a number of ud slices that are 
													//considered equivalent by symmetries
													




	ud_slice_sym_classes.fill(-1);							//The algorithm fills in all the permutations for one class before moving to the next
															//because it is going up from 0, the representent for a permutation 
															//in a class is the one with the smallest value

	std::array <short, 2048 * 495> ud_slice_symmetry;	//This tells you what symmetry is applied to 
														//a specific ud slice permutation

	std::array <short, 64430> ud_slice_sym_rep;		//This tells you the ud slice used to represent 
													//a specific ud slice permutation and the flip of all edges
													
													//the number of classes being 64430 was calculated by Kociemba
													//dividing 2048 * 495 by 16 gives 63360, which is close to the real value


	int ud_flip_value; //This value is used to define the permutation by its flip
				//and ud slice edge arrangement
	int ud_class = 0;


	for (short ud_slice = 0; ud_slice != 495; ud_slice++) {
		x.set_ud_slice_phase_1(ud_slice);
		for (short f = 0; f != 2048; f++) {
			c.set_flip(f);
			ud_flip_value = 2048 * ud_slice + f;

			if (ud_slice_sym_classes[ud_flip_value] == -1) {
				ud_slice_sym_classes[ud_flip_value] = ud_class;
				ud_slice_symmetry[ud_flip_value] = 0; //Its set to 0 because it is the base represent of the class
				ud_slice_sym_rep[ud_class] = ud_flip_value;
			}
			else{ continue; }

			for (short s = 0; s != 16; s++) {
				cubie sym = symmetries[s];

				sym.edge_multiply(c);
				sym.edge_multiply(inv_symmetries[s]);

				ud_flip_value = 2048 * sym.get_ud_slice_phase_1() + sym.get_flip();

				if (ud_slice_sym_classes[ud_flip_value] == -1) {
					ud_slice_sym_classes[ud_flip_value] = ud_class;
					ud_slice_symmetry[ud_flip_value] = s;
				}
			}
			ud_class++;
		}
	}

	//now we need to do something similar but with the coreners

	c.reset();
	x.reset();

	std::array <short, 40320> corn_sym_classes;	

												

	corn_sym_classes.fill(-1);										

	std::array <unsigned short, 40320> corn_symmetry;	

	std::array <unsigned short, 2768> corn_sym_rep;		//This tells you the corner permutation used to represent 
														//the permutations of a group or class of permutations
														//that are equivalent by symmetry

														//the number of classes being 2768 was also calculated by Kociemba
														//dividing 8! by 16 gives 2520, which is close to the real value


	short corn_value = 0;					//This value defines the permutation by the corner permutation
	int corn_class = 0;


	for (unsigned short corn = 0; corn != 40320; corn++) {
		c.set_corners(corn);

		if (corn_sym_classes[corn_value] == -1) {
			corn_sym_classes[corn_value] = corn_class;
			corn_symmetry[corn_value] = 0; //Its set to 0 because it is the base represent of the class
			corn_sym_rep[ud_class] = corn_value;
		}
		else { continue; }

		for (short s = 0; s != 16; s++) {
			cubie sym = symmetries[s];

			sym.corner_multiply(c);
			sym.corner_multiply(inv_symmetries[s]);

			corn_value = sym.get_corners();

			if (corn_sym_classes[corn_value] == -1) {
				corn_sym_classes[corn_value] = ud_class;
				corn_symmetry[corn_value] = s;
			}
		}
		corn_class++;
		
	}




}




